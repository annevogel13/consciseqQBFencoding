# 2/2 (black/white) Action variables, 1 and 2 (action parameter) index variables (x, y), and game stop variables : 
exists(1, 2, 3, 4, 5, 6)
forall(7, 8, 9, 10, 11, 15)
# white illegal variable: 
exists(12)
# indicator variables, specifying which position is voilated in illegal move: 
exists(13, 14)
exists(16, 17, 18, 19, 20, 21)
forall(22, 23, 24, 25, 26, 30)
# white illegal variable: 
exists(27)
# indicator variables, specifying which position is voilated in illegal move: 
exists(28, 29)
exists(31, 32, 33, 34, 35, 36)
forall(37, 38, 39, 40, 41, 45)
# white illegal variable: 
exists(42)
# indicator variables, specifying which position is voilated in illegal move: 
exists(43, 44)
exists(46, 47, 48, 49, 50, 51)
forall(52, 53, 54, 55, 56, 60)
# white illegal variable: 
exists(57)
# indicator variables, specifying which position is voilated in illegal move: 
exists(58, 59)
exists(61, 62, 63, 64, 65, 66)
forall(67, 68, 69, 70, 71, 75)
# white illegal variable: 
exists(72)
# indicator variables, specifying which position is voilated in illegal move: 
exists(73, 74)
exists(76, 77, 78, 79, 80, 81)
forall(82, 83, 84, 85, 86, 90)
# white illegal variable: 
exists(87)
# indicator variables, specifying which position is voilated in illegal move: 
exists(88, 89)
exists(91, 92, 93, 94, 95, 96)
# black goal index variables: 
exists(97)
# white goal index and conjunction variables: 
# Forall index variables: 
forall(98, 99, 100)
# Predicate variables: 
exists(101, 102)
exists(103, 104)
exists(105, 106)
exists(107, 108)
exists(109, 110)
exists(111, 112)
exists(113, 114)
exists(115, 116)
exists(117, 118)
exists(119, 120)
exists(121, 122)
exists(123, 124)
exists(125, 126)
exists(127, 128)
output(1279)
# ------------------------------------------------------------------------
# Transitions: 
# Player 1 (black) transition function for time step 0: 
# less than constraints for black moves:
129 = and(1, -2)
130 = or(-1, 129)
# propagation constraints:
131 = or(-101, 103)
132 = or(-103, 101)
133 = and(131, 132)
134 = or(-102, 104)
135 = or(-104, 102)
136 = and(134, 135)
137 = and(133, 136)
138 = and(-1, -2)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
# less than constraints for negative index bounds:
139 = and(-4, -5)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
140 = or(-3, 98)
141 = or(-98, 3)
142 = and(140, 141)
# new y constraint equality gate with forall y variables: 
143 = or(-4, 99)
144 = or(-99, 4)
145 = and(143, 144)
146 = or(-5, 100)
147 = or(-100, 5)
148 = and(146, 147)
149 = and(145, 148)
150 = and(142, 149)
151 = and(101, -102)
# if then constraint for black predicate:
152 = or(-150, 151)
# computing x variables for constraints,['?x', '?y-1'] add/sub/none:
# computing y variables for constraints,['?x', '?y-1'] add/sub/none:
# subtractor circuit
153 = or()
154 = or(153, 5)
155 = or(-153, 5)
156 = or(-5, 153)
157 = and(155, 156)
158 = or(-154, 4)
159 = or(-4, 154)
160 = and(158, 159)
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
161 = or(-160, 99)
162 = or(-99, 160)
163 = and(161, 162)
164 = or(-157, 100)
165 = or(-100, 157)
166 = and(164, 165)
167 = and(163, 166)
168 = and(142, 167)
169 = or(-168, -101)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
170 = or(-150, -103)
# computing x variables for constraints,['?x', '?y-1'] add/sub/none:
# computing y variables for constraints,['?x', '?y-1'] add/sub/none:
# subtractor circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
171 = and(103, -104)
# if then constraint for black predicate:
172 = or(-168, 171)
# disjunction for all touched positions:
173 = or(150, 168)
# frame axiom; if not touched position, then it is propagated:
174 = or(173, 137)
# conjunction for all the then constraints:
175 = and(-139, 152, 169, 170, 172, 174)
# final if then constraint for current action:
176 = or(-138, 175)
177 = and(-1, 2)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
# less than constraints for negative index bounds:
# less than constraints for negative index bounds:
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for black predicate:
# computing x variables for constraints,['?x-1', '?y-1'] add/sub/none:
# subtractor circuit
178 = or(-153, 3)
179 = or(-3, 153)
180 = and(178, 179)
# computing y variables for constraints,['?x-1', '?y-1'] add/sub/none:
# subtractor circuit
# new x constraint equality gate with forall x variables: 
181 = or(-180, 98)
182 = or(-98, 180)
183 = and(181, 182)
# new y constraint equality gate with forall y variables: 
184 = and(183, 167)
# if then constraint for black predicate:
185 = or(-184, -151)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# computing x variables for constraints,['?x-1', '?y-1'] add/sub/none:
# subtractor circuit
# computing y variables for constraints,['?x-1', '?y-1'] add/sub/none:
# subtractor circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for black predicate:
186 = or(-184, 171)
# disjunction for all touched positions:
187 = or(150, 184)
# frame axiom; if not touched position, then it is propagated:
188 = or(187, 137)
# conjunction for all the then constraints:
189 = and(3, -139, 152, 185, 170, 186, 188)
# final if then constraint for current action:
190 = or(-177, 189)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
# less than constraints for negative index bounds:
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for black predicate:
# computing x variables for constraints,['?x+1', '?y-1'] add/sub/none:
# adder circuit
# computing y variables for constraints,['?x+1', '?y-1'] add/sub/none:
# subtractor circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for black predicate:
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# computing x variables for constraints,['?x+1', '?y-1'] add/sub/none:
# adder circuit
# computing y variables for constraints,['?x+1', '?y-1'] add/sub/none:
# subtractor circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for black predicate:
# disjunction for all touched positions:
# frame axiom; if not touched position, then it is propagated:
# conjunction for all the then constraints:
191 = and(-3, -139, 152, 185, 170, 186, 188)
# final if then constraint for current action:
192 = or(-129, 191)
193 = and(130, 176, 190, 192)
# Player 2 (white) transition function for time step 1: 
# propagation constraints:
194 = or(-103, 105)
195 = or(-105, 103)
196 = and(194, 195)
197 = or(-104, 106)
198 = or(-106, 104)
199 = and(197, 198)
200 = and(196, 199)
# less than constraints for white moves:
201 = and(7, -8)
202 = or(-7, 201)
# generating less than bounds for indexes:
203 = and(-7, -8)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
204 = and(10, -11)
205 = or(-10, 204)
206 = or(-203, 205)
207 = and(-7, 8)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
# less than constraints for negative index bounds:
208 = and(205, 9)
209 = or(-207, 208)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
210 = and(-9, 205)
211 = or(-201, 210)
# conjunction for all the bound constraints:
212 = and(202, 206, 209, 211)
# single equality gate for the bound boolean variale and the final bound conjuction gate:
213 = or(-12, 212)
214 = or(-212, 12)
215 = and(213, 214)
# generating precondition equalities with boolean variables:
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
216 = or(-9, 98)
217 = or(-98, 9)
218 = and(216, 217)
# new y constraint equality gate with forall y variables: 
219 = or(-10, 99)
220 = or(-99, 10)
221 = and(219, 220)
222 = or(-11, 100)
223 = or(-100, 11)
224 = and(222, 223)
225 = and(221, 224)
226 = and(218, 225)
227 = and(103, 104)
# if then constraint for white predicate:
228 = or(-227, 13)
229 = or(-13, 227)
230 = and(228, 229)
231 = or(-203, -226, 230)
# computing x variables for constraints,['?x', '?y+1'] add/sub/none:
# computing y variables for constraints,['?x', '?y+1'] add/sub/none:
# adder circuit
232 = or(153, 11)
233 = or(-153, 11)
234 = or(-11, 153)
235 = and(233, 234)
236 = or(-232, 10)
237 = or(-10, 232)
238 = and(236, 237)
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
239 = or(238, 99)
240 = or(-99, -238)
241 = and(239, 240)
242 = or(-235, 100)
243 = or(-100, 235)
244 = and(242, 243)
245 = and(241, 244)
246 = and(218, 245)
247 = or(103, 14)
248 = or(-14, -103)
249 = and(247, 248)
250 = or(-203, -246, 249)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for white predicate:
251 = or(-207, -226, 230)
# computing x variables for constraints,['?x-1', '?y+1'] add/sub/none:
# subtractor circuit
252 = or(-153, 9)
253 = or(-9, 153)
254 = and(252, 253)
# computing y variables for constraints,['?x-1', '?y+1'] add/sub/none:
# adder circuit
# new x constraint equality gate with forall x variables: 
255 = or(-254, 98)
256 = or(-98, 254)
257 = and(255, 256)
# new y constraint equality gate with forall y variables: 
258 = and(257, 245)
# if then constraint for white predicate:
259 = or(227, 14)
260 = or(-14, -227)
261 = and(259, 260)
262 = or(-207, -258, 261)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for white predicate:
263 = or(-201, -226, 230)
# computing x variables for constraints,['?x+1', '?y+1'] add/sub/none:
# adder circuit
# computing y variables for constraints,['?x+1', '?y+1'] add/sub/none:
# adder circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for white predicate:
264 = or(-201, -258, 261)
# generating effects, implcation when the game is not stopped and bounds,preconditions hold:
265 = and(12, 13, 14)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
266 = or(-226, -105)
# computing x variables for constraints,['?x', '?y+1'] add/sub/none:
# computing y variables for constraints,['?x', '?y+1'] add/sub/none:
# adder circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
267 = and(105, 106)
# if then constraint for white predicate:
268 = or(-246, 267)
# disjunction for all touched positions:
269 = or(226, 246)
# frame axiom; if not touched position, then it is propagated:
270 = or(269, 200)
271 = and(266, 268, 270)
272 = and(265, 203)
273 = or(-272, 271)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# computing x variables for constraints,['?x-1', '?y+1'] add/sub/none:
# subtractor circuit
# computing y variables for constraints,['?x-1', '?y+1'] add/sub/none:
# adder circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for white predicate:
274 = or(-258, 267)
# disjunction for all touched positions:
275 = or(226, 258)
# frame axiom; if not touched position, then it is propagated:
276 = or(275, 200)
277 = and(266, 274, 276)
278 = and(265, 207)
279 = or(-278, 277)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# computing x variables for constraints,['?x+1', '?y+1'] add/sub/none:
# adder circuit
# computing y variables for constraints,['?x+1', '?y+1'] add/sub/none:
# adder circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for white predicate:
# disjunction for all touched positions:
# frame axiom; if not touched position, then it is propagated:
280 = and(265, 201)
281 = or(-280, 277)
282 = and(215, 231, 250, 251, 262, 263, 264, 273, 279, 281)
# Player 1 (black) transition function for time step 2: 
# less than constraints for black moves:
283 = and(16, -17)
284 = or(-16, 283)
# propagation constraints:
285 = or(-105, 107)
286 = or(-107, 105)
287 = and(285, 286)
288 = or(-106, 108)
289 = or(-108, 106)
290 = and(288, 289)
291 = and(287, 290)
292 = and(-16, -17)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
# less than constraints for negative index bounds:
293 = and(-19, -20)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
294 = or(-18, 98)
295 = or(-98, 18)
296 = and(294, 295)
# new y constraint equality gate with forall y variables: 
297 = or(-19, 99)
298 = or(-99, 19)
299 = and(297, 298)
300 = or(-20, 100)
301 = or(-100, 20)
302 = and(300, 301)
303 = and(299, 302)
304 = and(296, 303)
305 = and(105, -106)
# if then constraint for black predicate:
306 = or(-304, 305)
# computing x variables for constraints,['?x', '?y-1'] add/sub/none:
# computing y variables for constraints,['?x', '?y-1'] add/sub/none:
# subtractor circuit
307 = or(153, 20)
308 = or(-153, 20)
309 = or(-20, 153)
310 = and(308, 309)
311 = or(-307, 19)
312 = or(-19, 307)
313 = and(311, 312)
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
314 = or(-313, 99)
315 = or(-99, 313)
316 = and(314, 315)
317 = or(-310, 100)
318 = or(-100, 310)
319 = and(317, 318)
320 = and(316, 319)
321 = and(296, 320)
322 = or(-321, -105)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
323 = or(-304, -107)
# computing x variables for constraints,['?x', '?y-1'] add/sub/none:
# computing y variables for constraints,['?x', '?y-1'] add/sub/none:
# subtractor circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
324 = and(107, -108)
# if then constraint for black predicate:
325 = or(-321, 324)
# disjunction for all touched positions:
326 = or(304, 321)
# frame axiom; if not touched position, then it is propagated:
327 = or(326, 291)
# conjunction for all the then constraints:
328 = and(-293, 306, 322, 323, 325, 327)
# final if then constraint for current action:
329 = or(-292, 328)
330 = and(-16, 17)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
# less than constraints for negative index bounds:
# less than constraints for negative index bounds:
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for black predicate:
# computing x variables for constraints,['?x-1', '?y-1'] add/sub/none:
# subtractor circuit
331 = or(-153, 18)
332 = or(-18, 153)
333 = and(331, 332)
# computing y variables for constraints,['?x-1', '?y-1'] add/sub/none:
# subtractor circuit
# new x constraint equality gate with forall x variables: 
334 = or(-333, 98)
335 = or(-98, 333)
336 = and(334, 335)
# new y constraint equality gate with forall y variables: 
337 = and(336, 320)
# if then constraint for black predicate:
338 = or(-337, -305)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# computing x variables for constraints,['?x-1', '?y-1'] add/sub/none:
# subtractor circuit
# computing y variables for constraints,['?x-1', '?y-1'] add/sub/none:
# subtractor circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for black predicate:
339 = or(-337, 324)
# disjunction for all touched positions:
340 = or(304, 337)
# frame axiom; if not touched position, then it is propagated:
341 = or(340, 291)
# conjunction for all the then constraints:
342 = and(18, -293, 306, 338, 323, 339, 341)
# final if then constraint for current action:
343 = or(-330, 342)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
# less than constraints for negative index bounds:
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for black predicate:
# computing x variables for constraints,['?x+1', '?y-1'] add/sub/none:
# adder circuit
# computing y variables for constraints,['?x+1', '?y-1'] add/sub/none:
# subtractor circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for black predicate:
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# computing x variables for constraints,['?x+1', '?y-1'] add/sub/none:
# adder circuit
# computing y variables for constraints,['?x+1', '?y-1'] add/sub/none:
# subtractor circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for black predicate:
# disjunction for all touched positions:
# frame axiom; if not touched position, then it is propagated:
# conjunction for all the then constraints:
344 = and(-18, -293, 306, 338, 323, 339, 341)
# final if then constraint for current action:
345 = or(-283, 344)
346 = and(284, 329, 343, 345)
# Player 2 (white) transition function for time step 3: 
# propagation constraints:
347 = or(-107, 109)
348 = or(-109, 107)
349 = and(347, 348)
350 = or(-108, 110)
351 = or(-110, 108)
352 = and(350, 351)
353 = and(349, 352)
# less than constraints for white moves:
354 = and(22, -23)
355 = or(-22, 354)
# generating less than bounds for indexes:
356 = and(-22, -23)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
357 = and(25, -26)
358 = or(-25, 357)
359 = or(-356, 358)
360 = and(-22, 23)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
# less than constraints for negative index bounds:
361 = and(358, 24)
362 = or(-360, 361)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
363 = and(-24, 358)
364 = or(-354, 363)
# conjunction for all the bound constraints:
365 = and(355, 359, 362, 364)
# single equality gate for the bound boolean variale and the final bound conjuction gate:
366 = or(-27, 365)
367 = or(-365, 27)
368 = and(366, 367)
# generating precondition equalities with boolean variables:
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
369 = or(-24, 98)
370 = or(-98, 24)
371 = and(369, 370)
# new y constraint equality gate with forall y variables: 
372 = or(-25, 99)
373 = or(-99, 25)
374 = and(372, 373)
375 = or(-26, 100)
376 = or(-100, 26)
377 = and(375, 376)
378 = and(374, 377)
379 = and(371, 378)
380 = and(107, 108)
# if then constraint for white predicate:
381 = or(-380, 28)
382 = or(-28, 380)
383 = and(381, 382)
384 = or(-356, -379, 383)
# computing x variables for constraints,['?x', '?y+1'] add/sub/none:
# computing y variables for constraints,['?x', '?y+1'] add/sub/none:
# adder circuit
385 = or(153, 26)
386 = or(-153, 26)
387 = or(-26, 153)
388 = and(386, 387)
389 = or(-385, 25)
390 = or(-25, 385)
391 = and(389, 390)
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
392 = or(391, 99)
393 = or(-99, -391)
394 = and(392, 393)
395 = or(-388, 100)
396 = or(-100, 388)
397 = and(395, 396)
398 = and(394, 397)
399 = and(371, 398)
400 = or(107, 29)
401 = or(-29, -107)
402 = and(400, 401)
403 = or(-356, -399, 402)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for white predicate:
404 = or(-360, -379, 383)
# computing x variables for constraints,['?x-1', '?y+1'] add/sub/none:
# subtractor circuit
405 = or(-153, 24)
406 = or(-24, 153)
407 = and(405, 406)
# computing y variables for constraints,['?x-1', '?y+1'] add/sub/none:
# adder circuit
# new x constraint equality gate with forall x variables: 
408 = or(-407, 98)
409 = or(-98, 407)
410 = and(408, 409)
# new y constraint equality gate with forall y variables: 
411 = and(410, 398)
# if then constraint for white predicate:
412 = or(380, 29)
413 = or(-29, -380)
414 = and(412, 413)
415 = or(-360, -411, 414)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for white predicate:
416 = or(-354, -379, 383)
# computing x variables for constraints,['?x+1', '?y+1'] add/sub/none:
# adder circuit
# computing y variables for constraints,['?x+1', '?y+1'] add/sub/none:
# adder circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for white predicate:
417 = or(-354, -411, 414)
# generating effects, implcation when the game is not stopped and bounds,preconditions hold:
418 = and(27, 28, 29)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
419 = or(-379, -109)
# computing x variables for constraints,['?x', '?y+1'] add/sub/none:
# computing y variables for constraints,['?x', '?y+1'] add/sub/none:
# adder circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
420 = and(109, 110)
# if then constraint for white predicate:
421 = or(-399, 420)
# disjunction for all touched positions:
422 = or(379, 399)
# frame axiom; if not touched position, then it is propagated:
423 = or(422, 353)
424 = and(419, 421, 423)
425 = and(418, 356)
426 = or(-425, 424)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# computing x variables for constraints,['?x-1', '?y+1'] add/sub/none:
# subtractor circuit
# computing y variables for constraints,['?x-1', '?y+1'] add/sub/none:
# adder circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for white predicate:
427 = or(-411, 420)
# disjunction for all touched positions:
428 = or(379, 411)
# frame axiom; if not touched position, then it is propagated:
429 = or(428, 353)
430 = and(419, 427, 429)
431 = and(418, 360)
432 = or(-431, 430)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# computing x variables for constraints,['?x+1', '?y+1'] add/sub/none:
# adder circuit
# computing y variables for constraints,['?x+1', '?y+1'] add/sub/none:
# adder circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for white predicate:
# disjunction for all touched positions:
# frame axiom; if not touched position, then it is propagated:
433 = and(418, 354)
434 = or(-433, 430)
435 = and(368, 384, 403, 404, 415, 416, 417, 426, 432, 434)
# Player 1 (black) transition function for time step 4: 
# less than constraints for black moves:
436 = and(31, -32)
437 = or(-31, 436)
# propagation constraints:
438 = or(-109, 111)
439 = or(-111, 109)
440 = and(438, 439)
441 = or(-110, 112)
442 = or(-112, 110)
443 = and(441, 442)
444 = and(440, 443)
445 = and(-31, -32)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
# less than constraints for negative index bounds:
446 = and(-34, -35)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
447 = or(-33, 98)
448 = or(-98, 33)
449 = and(447, 448)
# new y constraint equality gate with forall y variables: 
450 = or(-34, 99)
451 = or(-99, 34)
452 = and(450, 451)
453 = or(-35, 100)
454 = or(-100, 35)
455 = and(453, 454)
456 = and(452, 455)
457 = and(449, 456)
458 = and(109, -110)
# if then constraint for black predicate:
459 = or(-457, 458)
# computing x variables for constraints,['?x', '?y-1'] add/sub/none:
# computing y variables for constraints,['?x', '?y-1'] add/sub/none:
# subtractor circuit
460 = or(153, 35)
461 = or(-153, 35)
462 = or(-35, 153)
463 = and(461, 462)
464 = or(-460, 34)
465 = or(-34, 460)
466 = and(464, 465)
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
467 = or(-466, 99)
468 = or(-99, 466)
469 = and(467, 468)
470 = or(-463, 100)
471 = or(-100, 463)
472 = and(470, 471)
473 = and(469, 472)
474 = and(449, 473)
475 = or(-474, -109)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
476 = or(-457, -111)
# computing x variables for constraints,['?x', '?y-1'] add/sub/none:
# computing y variables for constraints,['?x', '?y-1'] add/sub/none:
# subtractor circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
477 = and(111, -112)
# if then constraint for black predicate:
478 = or(-474, 477)
# disjunction for all touched positions:
479 = or(457, 474)
# frame axiom; if not touched position, then it is propagated:
480 = or(479, 444)
# conjunction for all the then constraints:
481 = and(-446, 459, 475, 476, 478, 480)
# final if then constraint for current action:
482 = or(-445, 481)
483 = and(-31, 32)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
# less than constraints for negative index bounds:
# less than constraints for negative index bounds:
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for black predicate:
# computing x variables for constraints,['?x-1', '?y-1'] add/sub/none:
# subtractor circuit
484 = or(-153, 33)
485 = or(-33, 153)
486 = and(484, 485)
# computing y variables for constraints,['?x-1', '?y-1'] add/sub/none:
# subtractor circuit
# new x constraint equality gate with forall x variables: 
487 = or(-486, 98)
488 = or(-98, 486)
489 = and(487, 488)
# new y constraint equality gate with forall y variables: 
490 = and(489, 473)
# if then constraint for black predicate:
491 = or(-490, -458)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# computing x variables for constraints,['?x-1', '?y-1'] add/sub/none:
# subtractor circuit
# computing y variables for constraints,['?x-1', '?y-1'] add/sub/none:
# subtractor circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for black predicate:
492 = or(-490, 477)
# disjunction for all touched positions:
493 = or(457, 490)
# frame axiom; if not touched position, then it is propagated:
494 = or(493, 444)
# conjunction for all the then constraints:
495 = and(33, -446, 459, 491, 476, 492, 494)
# final if then constraint for current action:
496 = or(-483, 495)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
# less than constraints for negative index bounds:
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for black predicate:
# computing x variables for constraints,['?x+1', '?y-1'] add/sub/none:
# adder circuit
# computing y variables for constraints,['?x+1', '?y-1'] add/sub/none:
# subtractor circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for black predicate:
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# computing x variables for constraints,['?x+1', '?y-1'] add/sub/none:
# adder circuit
# computing y variables for constraints,['?x+1', '?y-1'] add/sub/none:
# subtractor circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for black predicate:
# disjunction for all touched positions:
# frame axiom; if not touched position, then it is propagated:
# conjunction for all the then constraints:
497 = and(-33, -446, 459, 491, 476, 492, 494)
# final if then constraint for current action:
498 = or(-436, 497)
499 = and(437, 482, 496, 498)
# Player 2 (white) transition function for time step 5: 
# propagation constraints:
500 = or(-111, 113)
501 = or(-113, 111)
502 = and(500, 501)
503 = or(-112, 114)
504 = or(-114, 112)
505 = and(503, 504)
506 = and(502, 505)
# less than constraints for white moves:
507 = and(37, -38)
508 = or(-37, 507)
# generating less than bounds for indexes:
509 = and(-37, -38)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
510 = and(40, -41)
511 = or(-40, 510)
512 = or(-509, 511)
513 = and(-37, 38)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
# less than constraints for negative index bounds:
514 = and(511, 39)
515 = or(-513, 514)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
516 = and(-39, 511)
517 = or(-507, 516)
# conjunction for all the bound constraints:
518 = and(508, 512, 515, 517)
# single equality gate for the bound boolean variale and the final bound conjuction gate:
519 = or(-42, 518)
520 = or(-518, 42)
521 = and(519, 520)
# generating precondition equalities with boolean variables:
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
522 = or(-39, 98)
523 = or(-98, 39)
524 = and(522, 523)
# new y constraint equality gate with forall y variables: 
525 = or(-40, 99)
526 = or(-99, 40)
527 = and(525, 526)
528 = or(-41, 100)
529 = or(-100, 41)
530 = and(528, 529)
531 = and(527, 530)
532 = and(524, 531)
533 = and(111, 112)
# if then constraint for white predicate:
534 = or(-533, 43)
535 = or(-43, 533)
536 = and(534, 535)
537 = or(-509, -532, 536)
# computing x variables for constraints,['?x', '?y+1'] add/sub/none:
# computing y variables for constraints,['?x', '?y+1'] add/sub/none:
# adder circuit
538 = or(153, 41)
539 = or(-153, 41)
540 = or(-41, 153)
541 = and(539, 540)
542 = or(-538, 40)
543 = or(-40, 538)
544 = and(542, 543)
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
545 = or(544, 99)
546 = or(-99, -544)
547 = and(545, 546)
548 = or(-541, 100)
549 = or(-100, 541)
550 = and(548, 549)
551 = and(547, 550)
552 = and(524, 551)
553 = or(111, 44)
554 = or(-44, -111)
555 = and(553, 554)
556 = or(-509, -552, 555)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for white predicate:
557 = or(-513, -532, 536)
# computing x variables for constraints,['?x-1', '?y+1'] add/sub/none:
# subtractor circuit
558 = or(-153, 39)
559 = or(-39, 153)
560 = and(558, 559)
# computing y variables for constraints,['?x-1', '?y+1'] add/sub/none:
# adder circuit
# new x constraint equality gate with forall x variables: 
561 = or(-560, 98)
562 = or(-98, 560)
563 = and(561, 562)
# new y constraint equality gate with forall y variables: 
564 = and(563, 551)
# if then constraint for white predicate:
565 = or(533, 44)
566 = or(-44, -533)
567 = and(565, 566)
568 = or(-513, -564, 567)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for white predicate:
569 = or(-507, -532, 536)
# computing x variables for constraints,['?x+1', '?y+1'] add/sub/none:
# adder circuit
# computing y variables for constraints,['?x+1', '?y+1'] add/sub/none:
# adder circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for white predicate:
570 = or(-507, -564, 567)
# generating effects, implcation when the game is not stopped and bounds,preconditions hold:
571 = and(42, 43, 44)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
572 = or(-532, -113)
# computing x variables for constraints,['?x', '?y+1'] add/sub/none:
# computing y variables for constraints,['?x', '?y+1'] add/sub/none:
# adder circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
573 = and(113, 114)
# if then constraint for white predicate:
574 = or(-552, 573)
# disjunction for all touched positions:
575 = or(532, 552)
# frame axiom; if not touched position, then it is propagated:
576 = or(575, 506)
577 = and(572, 574, 576)
578 = and(571, 509)
579 = or(-578, 577)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# computing x variables for constraints,['?x-1', '?y+1'] add/sub/none:
# subtractor circuit
# computing y variables for constraints,['?x-1', '?y+1'] add/sub/none:
# adder circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for white predicate:
580 = or(-564, 573)
# disjunction for all touched positions:
581 = or(532, 564)
# frame axiom; if not touched position, then it is propagated:
582 = or(581, 506)
583 = and(572, 580, 582)
584 = and(571, 513)
585 = or(-584, 583)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# computing x variables for constraints,['?x+1', '?y+1'] add/sub/none:
# adder circuit
# computing y variables for constraints,['?x+1', '?y+1'] add/sub/none:
# adder circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for white predicate:
# disjunction for all touched positions:
# frame axiom; if not touched position, then it is propagated:
586 = and(571, 507)
587 = or(-586, 583)
588 = and(521, 537, 556, 557, 568, 569, 570, 579, 585, 587)
# Player 1 (black) transition function for time step 6: 
# less than constraints for black moves:
589 = and(46, -47)
590 = or(-46, 589)
# propagation constraints:
591 = or(-113, 115)
592 = or(-115, 113)
593 = and(591, 592)
594 = or(-114, 116)
595 = or(-116, 114)
596 = and(594, 595)
597 = and(593, 596)
598 = and(-46, -47)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
# less than constraints for negative index bounds:
599 = and(-49, -50)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
600 = or(-48, 98)
601 = or(-98, 48)
602 = and(600, 601)
# new y constraint equality gate with forall y variables: 
603 = or(-49, 99)
604 = or(-99, 49)
605 = and(603, 604)
606 = or(-50, 100)
607 = or(-100, 50)
608 = and(606, 607)
609 = and(605, 608)
610 = and(602, 609)
611 = and(113, -114)
# if then constraint for black predicate:
612 = or(-610, 611)
# computing x variables for constraints,['?x', '?y-1'] add/sub/none:
# computing y variables for constraints,['?x', '?y-1'] add/sub/none:
# subtractor circuit
613 = or(153, 50)
614 = or(-153, 50)
615 = or(-50, 153)
616 = and(614, 615)
617 = or(-613, 49)
618 = or(-49, 613)
619 = and(617, 618)
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
620 = or(-619, 99)
621 = or(-99, 619)
622 = and(620, 621)
623 = or(-616, 100)
624 = or(-100, 616)
625 = and(623, 624)
626 = and(622, 625)
627 = and(602, 626)
628 = or(-627, -113)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
629 = or(-610, -115)
# computing x variables for constraints,['?x', '?y-1'] add/sub/none:
# computing y variables for constraints,['?x', '?y-1'] add/sub/none:
# subtractor circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
630 = and(115, -116)
# if then constraint for black predicate:
631 = or(-627, 630)
# disjunction for all touched positions:
632 = or(610, 627)
# frame axiom; if not touched position, then it is propagated:
633 = or(632, 597)
# conjunction for all the then constraints:
634 = and(-599, 612, 628, 629, 631, 633)
# final if then constraint for current action:
635 = or(-598, 634)
636 = and(-46, 47)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
# less than constraints for negative index bounds:
# less than constraints for negative index bounds:
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for black predicate:
# computing x variables for constraints,['?x-1', '?y-1'] add/sub/none:
# subtractor circuit
637 = or(-153, 48)
638 = or(-48, 153)
639 = and(637, 638)
# computing y variables for constraints,['?x-1', '?y-1'] add/sub/none:
# subtractor circuit
# new x constraint equality gate with forall x variables: 
640 = or(-639, 98)
641 = or(-98, 639)
642 = and(640, 641)
# new y constraint equality gate with forall y variables: 
643 = and(642, 626)
# if then constraint for black predicate:
644 = or(-643, -611)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# computing x variables for constraints,['?x-1', '?y-1'] add/sub/none:
# subtractor circuit
# computing y variables for constraints,['?x-1', '?y-1'] add/sub/none:
# subtractor circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for black predicate:
645 = or(-643, 630)
# disjunction for all touched positions:
646 = or(610, 643)
# frame axiom; if not touched position, then it is propagated:
647 = or(646, 597)
# conjunction for all the then constraints:
648 = and(48, -599, 612, 644, 629, 645, 647)
# final if then constraint for current action:
649 = or(-636, 648)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
# less than constraints for negative index bounds:
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for black predicate:
# computing x variables for constraints,['?x+1', '?y-1'] add/sub/none:
# adder circuit
# computing y variables for constraints,['?x+1', '?y-1'] add/sub/none:
# subtractor circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for black predicate:
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# computing x variables for constraints,['?x+1', '?y-1'] add/sub/none:
# adder circuit
# computing y variables for constraints,['?x+1', '?y-1'] add/sub/none:
# subtractor circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for black predicate:
# disjunction for all touched positions:
# frame axiom; if not touched position, then it is propagated:
# conjunction for all the then constraints:
650 = and(-48, -599, 612, 644, 629, 645, 647)
# final if then constraint for current action:
651 = or(-589, 650)
652 = and(590, 635, 649, 651)
# Player 2 (white) transition function for time step 7: 
# propagation constraints:
653 = or(-115, 117)
654 = or(-117, 115)
655 = and(653, 654)
656 = or(-116, 118)
657 = or(-118, 116)
658 = and(656, 657)
659 = and(655, 658)
# less than constraints for white moves:
660 = and(52, -53)
661 = or(-52, 660)
# generating less than bounds for indexes:
662 = and(-52, -53)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
663 = and(55, -56)
664 = or(-55, 663)
665 = or(-662, 664)
666 = and(-52, 53)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
# less than constraints for negative index bounds:
667 = and(664, 54)
668 = or(-666, 667)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
669 = and(-54, 664)
670 = or(-660, 669)
# conjunction for all the bound constraints:
671 = and(661, 665, 668, 670)
# single equality gate for the bound boolean variale and the final bound conjuction gate:
672 = or(-57, 671)
673 = or(-671, 57)
674 = and(672, 673)
# generating precondition equalities with boolean variables:
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
675 = or(-54, 98)
676 = or(-98, 54)
677 = and(675, 676)
# new y constraint equality gate with forall y variables: 
678 = or(-55, 99)
679 = or(-99, 55)
680 = and(678, 679)
681 = or(-56, 100)
682 = or(-100, 56)
683 = and(681, 682)
684 = and(680, 683)
685 = and(677, 684)
686 = and(115, 116)
# if then constraint for white predicate:
687 = or(-686, 58)
688 = or(-58, 686)
689 = and(687, 688)
690 = or(-662, -685, 689)
# computing x variables for constraints,['?x', '?y+1'] add/sub/none:
# computing y variables for constraints,['?x', '?y+1'] add/sub/none:
# adder circuit
691 = or(153, 56)
692 = or(-153, 56)
693 = or(-56, 153)
694 = and(692, 693)
695 = or(-691, 55)
696 = or(-55, 691)
697 = and(695, 696)
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
698 = or(697, 99)
699 = or(-99, -697)
700 = and(698, 699)
701 = or(-694, 100)
702 = or(-100, 694)
703 = and(701, 702)
704 = and(700, 703)
705 = and(677, 704)
706 = or(115, 59)
707 = or(-59, -115)
708 = and(706, 707)
709 = or(-662, -705, 708)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for white predicate:
710 = or(-666, -685, 689)
# computing x variables for constraints,['?x-1', '?y+1'] add/sub/none:
# subtractor circuit
711 = or(-153, 54)
712 = or(-54, 153)
713 = and(711, 712)
# computing y variables for constraints,['?x-1', '?y+1'] add/sub/none:
# adder circuit
# new x constraint equality gate with forall x variables: 
714 = or(-713, 98)
715 = or(-98, 713)
716 = and(714, 715)
# new y constraint equality gate with forall y variables: 
717 = and(716, 704)
# if then constraint for white predicate:
718 = or(686, 59)
719 = or(-59, -686)
720 = and(718, 719)
721 = or(-666, -717, 720)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for white predicate:
722 = or(-660, -685, 689)
# computing x variables for constraints,['?x+1', '?y+1'] add/sub/none:
# adder circuit
# computing y variables for constraints,['?x+1', '?y+1'] add/sub/none:
# adder circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for white predicate:
723 = or(-660, -717, 720)
# generating effects, implcation when the game is not stopped and bounds,preconditions hold:
724 = and(57, 58, 59)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
725 = or(-685, -117)
# computing x variables for constraints,['?x', '?y+1'] add/sub/none:
# computing y variables for constraints,['?x', '?y+1'] add/sub/none:
# adder circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
726 = and(117, 118)
# if then constraint for white predicate:
727 = or(-705, 726)
# disjunction for all touched positions:
728 = or(685, 705)
# frame axiom; if not touched position, then it is propagated:
729 = or(728, 659)
730 = and(725, 727, 729)
731 = and(724, 662)
732 = or(-731, 730)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# computing x variables for constraints,['?x-1', '?y+1'] add/sub/none:
# subtractor circuit
# computing y variables for constraints,['?x-1', '?y+1'] add/sub/none:
# adder circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for white predicate:
733 = or(-717, 726)
# disjunction for all touched positions:
734 = or(685, 717)
# frame axiom; if not touched position, then it is propagated:
735 = or(734, 659)
736 = and(725, 733, 735)
737 = and(724, 666)
738 = or(-737, 736)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# computing x variables for constraints,['?x+1', '?y+1'] add/sub/none:
# adder circuit
# computing y variables for constraints,['?x+1', '?y+1'] add/sub/none:
# adder circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for white predicate:
# disjunction for all touched positions:
# frame axiom; if not touched position, then it is propagated:
739 = and(724, 660)
740 = or(-739, 736)
741 = and(674, 690, 709, 710, 721, 722, 723, 732, 738, 740)
# Player 1 (black) transition function for time step 8: 
# less than constraints for black moves:
742 = and(61, -62)
743 = or(-61, 742)
# propagation constraints:
744 = or(-117, 119)
745 = or(-119, 117)
746 = and(744, 745)
747 = or(-118, 120)
748 = or(-120, 118)
749 = and(747, 748)
750 = and(746, 749)
751 = and(-61, -62)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
# less than constraints for negative index bounds:
752 = and(-64, -65)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
753 = or(-63, 98)
754 = or(-98, 63)
755 = and(753, 754)
# new y constraint equality gate with forall y variables: 
756 = or(-64, 99)
757 = or(-99, 64)
758 = and(756, 757)
759 = or(-65, 100)
760 = or(-100, 65)
761 = and(759, 760)
762 = and(758, 761)
763 = and(755, 762)
764 = and(117, -118)
# if then constraint for black predicate:
765 = or(-763, 764)
# computing x variables for constraints,['?x', '?y-1'] add/sub/none:
# computing y variables for constraints,['?x', '?y-1'] add/sub/none:
# subtractor circuit
766 = or(153, 65)
767 = or(-153, 65)
768 = or(-65, 153)
769 = and(767, 768)
770 = or(-766, 64)
771 = or(-64, 766)
772 = and(770, 771)
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
773 = or(-772, 99)
774 = or(-99, 772)
775 = and(773, 774)
776 = or(-769, 100)
777 = or(-100, 769)
778 = and(776, 777)
779 = and(775, 778)
780 = and(755, 779)
781 = or(-780, -117)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
782 = or(-763, -119)
# computing x variables for constraints,['?x', '?y-1'] add/sub/none:
# computing y variables for constraints,['?x', '?y-1'] add/sub/none:
# subtractor circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
783 = and(119, -120)
# if then constraint for black predicate:
784 = or(-780, 783)
# disjunction for all touched positions:
785 = or(763, 780)
# frame axiom; if not touched position, then it is propagated:
786 = or(785, 750)
# conjunction for all the then constraints:
787 = and(-752, 765, 781, 782, 784, 786)
# final if then constraint for current action:
788 = or(-751, 787)
789 = and(-61, 62)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
# less than constraints for negative index bounds:
# less than constraints for negative index bounds:
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for black predicate:
# computing x variables for constraints,['?x-1', '?y-1'] add/sub/none:
# subtractor circuit
790 = or(-153, 63)
791 = or(-63, 153)
792 = and(790, 791)
# computing y variables for constraints,['?x-1', '?y-1'] add/sub/none:
# subtractor circuit
# new x constraint equality gate with forall x variables: 
793 = or(-792, 98)
794 = or(-98, 792)
795 = and(793, 794)
# new y constraint equality gate with forall y variables: 
796 = and(795, 779)
# if then constraint for black predicate:
797 = or(-796, -764)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# computing x variables for constraints,['?x-1', '?y-1'] add/sub/none:
# subtractor circuit
# computing y variables for constraints,['?x-1', '?y-1'] add/sub/none:
# subtractor circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for black predicate:
798 = or(-796, 783)
# disjunction for all touched positions:
799 = or(763, 796)
# frame axiom; if not touched position, then it is propagated:
800 = or(799, 750)
# conjunction for all the then constraints:
801 = and(63, -752, 765, 797, 782, 798, 800)
# final if then constraint for current action:
802 = or(-789, 801)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
# less than constraints for negative index bounds:
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for black predicate:
# computing x variables for constraints,['?x+1', '?y-1'] add/sub/none:
# adder circuit
# computing y variables for constraints,['?x+1', '?y-1'] add/sub/none:
# subtractor circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for black predicate:
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# computing x variables for constraints,['?x+1', '?y-1'] add/sub/none:
# adder circuit
# computing y variables for constraints,['?x+1', '?y-1'] add/sub/none:
# subtractor circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for black predicate:
# disjunction for all touched positions:
# frame axiom; if not touched position, then it is propagated:
# conjunction for all the then constraints:
803 = and(-63, -752, 765, 797, 782, 798, 800)
# final if then constraint for current action:
804 = or(-742, 803)
805 = and(743, 788, 802, 804)
# Player 2 (white) transition function for time step 9: 
# propagation constraints:
806 = or(-119, 121)
807 = or(-121, 119)
808 = and(806, 807)
809 = or(-120, 122)
810 = or(-122, 120)
811 = and(809, 810)
812 = and(808, 811)
# less than constraints for white moves:
813 = and(67, -68)
814 = or(-67, 813)
# generating less than bounds for indexes:
815 = and(-67, -68)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
816 = and(70, -71)
817 = or(-70, 816)
818 = or(-815, 817)
819 = and(-67, 68)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
# less than constraints for negative index bounds:
820 = and(817, 69)
821 = or(-819, 820)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
822 = and(-69, 817)
823 = or(-813, 822)
# conjunction for all the bound constraints:
824 = and(814, 818, 821, 823)
# single equality gate for the bound boolean variale and the final bound conjuction gate:
825 = or(-72, 824)
826 = or(-824, 72)
827 = and(825, 826)
# generating precondition equalities with boolean variables:
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
828 = or(-69, 98)
829 = or(-98, 69)
830 = and(828, 829)
# new y constraint equality gate with forall y variables: 
831 = or(-70, 99)
832 = or(-99, 70)
833 = and(831, 832)
834 = or(-71, 100)
835 = or(-100, 71)
836 = and(834, 835)
837 = and(833, 836)
838 = and(830, 837)
839 = and(119, 120)
# if then constraint for white predicate:
840 = or(-839, 73)
841 = or(-73, 839)
842 = and(840, 841)
843 = or(-815, -838, 842)
# computing x variables for constraints,['?x', '?y+1'] add/sub/none:
# computing y variables for constraints,['?x', '?y+1'] add/sub/none:
# adder circuit
844 = or(153, 71)
845 = or(-153, 71)
846 = or(-71, 153)
847 = and(845, 846)
848 = or(-844, 70)
849 = or(-70, 844)
850 = and(848, 849)
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
851 = or(850, 99)
852 = or(-99, -850)
853 = and(851, 852)
854 = or(-847, 100)
855 = or(-100, 847)
856 = and(854, 855)
857 = and(853, 856)
858 = and(830, 857)
859 = or(119, 74)
860 = or(-74, -119)
861 = and(859, 860)
862 = or(-815, -858, 861)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for white predicate:
863 = or(-819, -838, 842)
# computing x variables for constraints,['?x-1', '?y+1'] add/sub/none:
# subtractor circuit
864 = or(-153, 69)
865 = or(-69, 153)
866 = and(864, 865)
# computing y variables for constraints,['?x-1', '?y+1'] add/sub/none:
# adder circuit
# new x constraint equality gate with forall x variables: 
867 = or(-866, 98)
868 = or(-98, 866)
869 = and(867, 868)
# new y constraint equality gate with forall y variables: 
870 = and(869, 857)
# if then constraint for white predicate:
871 = or(839, 74)
872 = or(-74, -839)
873 = and(871, 872)
874 = or(-819, -870, 873)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for white predicate:
875 = or(-813, -838, 842)
# computing x variables for constraints,['?x+1', '?y+1'] add/sub/none:
# adder circuit
# computing y variables for constraints,['?x+1', '?y+1'] add/sub/none:
# adder circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for white predicate:
876 = or(-813, -870, 873)
# generating effects, implcation when the game is not stopped and bounds,preconditions hold:
877 = and(72, 73, 74)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
878 = or(-838, -121)
# computing x variables for constraints,['?x', '?y+1'] add/sub/none:
# computing y variables for constraints,['?x', '?y+1'] add/sub/none:
# adder circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
879 = and(121, 122)
# if then constraint for white predicate:
880 = or(-858, 879)
# disjunction for all touched positions:
881 = or(838, 858)
# frame axiom; if not touched position, then it is propagated:
882 = or(881, 812)
883 = and(878, 880, 882)
884 = and(877, 815)
885 = or(-884, 883)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# computing x variables for constraints,['?x-1', '?y+1'] add/sub/none:
# subtractor circuit
# computing y variables for constraints,['?x-1', '?y+1'] add/sub/none:
# adder circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for white predicate:
886 = or(-870, 879)
# disjunction for all touched positions:
887 = or(838, 870)
# frame axiom; if not touched position, then it is propagated:
888 = or(887, 812)
889 = and(878, 886, 888)
890 = and(877, 819)
891 = or(-890, 889)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# computing x variables for constraints,['?x+1', '?y+1'] add/sub/none:
# adder circuit
# computing y variables for constraints,['?x+1', '?y+1'] add/sub/none:
# adder circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for white predicate:
# disjunction for all touched positions:
# frame axiom; if not touched position, then it is propagated:
892 = and(877, 813)
893 = or(-892, 889)
894 = and(827, 843, 862, 863, 874, 875, 876, 885, 891, 893)
# Player 1 (black) transition function for time step 10: 
# less than constraints for black moves:
895 = and(76, -77)
896 = or(-76, 895)
# propagation constraints:
897 = or(-121, 123)
898 = or(-123, 121)
899 = and(897, 898)
900 = or(-122, 124)
901 = or(-124, 122)
902 = and(900, 901)
903 = and(899, 902)
904 = and(-76, -77)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
# less than constraints for negative index bounds:
905 = and(-79, -80)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
906 = or(-78, 98)
907 = or(-98, 78)
908 = and(906, 907)
# new y constraint equality gate with forall y variables: 
909 = or(-79, 99)
910 = or(-99, 79)
911 = and(909, 910)
912 = or(-80, 100)
913 = or(-100, 80)
914 = and(912, 913)
915 = and(911, 914)
916 = and(908, 915)
917 = and(121, -122)
# if then constraint for black predicate:
918 = or(-916, 917)
# computing x variables for constraints,['?x', '?y-1'] add/sub/none:
# computing y variables for constraints,['?x', '?y-1'] add/sub/none:
# subtractor circuit
919 = or(153, 80)
920 = or(-153, 80)
921 = or(-80, 153)
922 = and(920, 921)
923 = or(-919, 79)
924 = or(-79, 919)
925 = and(923, 924)
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
926 = or(-925, 99)
927 = or(-99, 925)
928 = and(926, 927)
929 = or(-922, 100)
930 = or(-100, 922)
931 = and(929, 930)
932 = and(928, 931)
933 = and(908, 932)
934 = or(-933, -121)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
935 = or(-916, -123)
# computing x variables for constraints,['?x', '?y-1'] add/sub/none:
# computing y variables for constraints,['?x', '?y-1'] add/sub/none:
# subtractor circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
936 = and(123, -124)
# if then constraint for black predicate:
937 = or(-933, 936)
# disjunction for all touched positions:
938 = or(916, 933)
# frame axiom; if not touched position, then it is propagated:
939 = or(938, 903)
# conjunction for all the then constraints:
940 = and(-905, 918, 934, 935, 937, 939)
# final if then constraint for current action:
941 = or(-904, 940)
942 = and(-76, 77)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
# less than constraints for negative index bounds:
# less than constraints for negative index bounds:
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for black predicate:
# computing x variables for constraints,['?x-1', '?y-1'] add/sub/none:
# subtractor circuit
943 = or(-153, 78)
944 = or(-78, 153)
945 = and(943, 944)
# computing y variables for constraints,['?x-1', '?y-1'] add/sub/none:
# subtractor circuit
# new x constraint equality gate with forall x variables: 
946 = or(-945, 98)
947 = or(-98, 945)
948 = and(946, 947)
# new y constraint equality gate with forall y variables: 
949 = and(948, 932)
# if then constraint for black predicate:
950 = or(-949, -917)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# computing x variables for constraints,['?x-1', '?y-1'] add/sub/none:
# subtractor circuit
# computing y variables for constraints,['?x-1', '?y-1'] add/sub/none:
# subtractor circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for black predicate:
951 = or(-949, 936)
# disjunction for all touched positions:
952 = or(916, 949)
# frame axiom; if not touched position, then it is propagated:
953 = or(952, 903)
# conjunction for all the then constraints:
954 = and(78, -905, 918, 950, 935, 951, 953)
# final if then constraint for current action:
955 = or(-942, 954)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
# less than constraints for negative index bounds:
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for black predicate:
# computing x variables for constraints,['?x+1', '?y-1'] add/sub/none:
# adder circuit
# computing y variables for constraints,['?x+1', '?y-1'] add/sub/none:
# subtractor circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for black predicate:
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# computing x variables for constraints,['?x+1', '?y-1'] add/sub/none:
# adder circuit
# computing y variables for constraints,['?x+1', '?y-1'] add/sub/none:
# subtractor circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for black predicate:
# disjunction for all touched positions:
# frame axiom; if not touched position, then it is propagated:
# conjunction for all the then constraints:
956 = and(-78, -905, 918, 950, 935, 951, 953)
# final if then constraint for current action:
957 = or(-895, 956)
958 = and(896, 941, 955, 957)
# Player 2 (white) transition function for time step 11: 
# propagation constraints:
959 = or(-123, 125)
960 = or(-125, 123)
961 = and(959, 960)
962 = or(-124, 126)
963 = or(-126, 124)
964 = and(962, 963)
965 = and(961, 964)
# less than constraints for white moves:
966 = and(82, -83)
967 = or(-82, 966)
# generating less than bounds for indexes:
968 = and(-82, -83)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
969 = and(85, -86)
970 = or(-85, 969)
971 = or(-968, 970)
972 = and(-82, 83)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
# less than constraints for negative index bounds:
973 = and(970, 84)
974 = or(-972, 973)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
975 = and(-84, 970)
976 = or(-966, 975)
# conjunction for all the bound constraints:
977 = and(967, 971, 974, 976)
# single equality gate for the bound boolean variale and the final bound conjuction gate:
978 = or(-87, 977)
979 = or(-977, 87)
980 = and(978, 979)
# generating precondition equalities with boolean variables:
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
981 = or(-84, 98)
982 = or(-98, 84)
983 = and(981, 982)
# new y constraint equality gate with forall y variables: 
984 = or(-85, 99)
985 = or(-99, 85)
986 = and(984, 985)
987 = or(-86, 100)
988 = or(-100, 86)
989 = and(987, 988)
990 = and(986, 989)
991 = and(983, 990)
992 = and(123, 124)
# if then constraint for white predicate:
993 = or(-992, 88)
994 = or(-88, 992)
995 = and(993, 994)
996 = or(-968, -991, 995)
# computing x variables for constraints,['?x', '?y+1'] add/sub/none:
# computing y variables for constraints,['?x', '?y+1'] add/sub/none:
# adder circuit
997 = or(153, 86)
998 = or(-153, 86)
999 = or(-86, 153)
1000 = and(998, 999)
1001 = or(-997, 85)
1002 = or(-85, 997)
1003 = and(1001, 1002)
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
1004 = or(1003, 99)
1005 = or(-99, -1003)
1006 = and(1004, 1005)
1007 = or(-1000, 100)
1008 = or(-100, 1000)
1009 = and(1007, 1008)
1010 = and(1006, 1009)
1011 = and(983, 1010)
1012 = or(123, 89)
1013 = or(-89, -123)
1014 = and(1012, 1013)
1015 = or(-968, -1011, 1014)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for white predicate:
1016 = or(-972, -991, 995)
# computing x variables for constraints,['?x-1', '?y+1'] add/sub/none:
# subtractor circuit
1017 = or(-153, 84)
1018 = or(-84, 153)
1019 = and(1017, 1018)
# computing y variables for constraints,['?x-1', '?y+1'] add/sub/none:
# adder circuit
# new x constraint equality gate with forall x variables: 
1020 = or(-1019, 98)
1021 = or(-98, 1019)
1022 = and(1020, 1021)
# new y constraint equality gate with forall y variables: 
1023 = and(1022, 1010)
# if then constraint for white predicate:
1024 = or(992, 89)
1025 = or(-89, -992)
1026 = and(1024, 1025)
1027 = or(-972, -1023, 1026)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for white predicate:
1028 = or(-966, -991, 995)
# computing x variables for constraints,['?x+1', '?y+1'] add/sub/none:
# adder circuit
# computing y variables for constraints,['?x+1', '?y+1'] add/sub/none:
# adder circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for white predicate:
1029 = or(-966, -1023, 1026)
# generating effects, implcation when the game is not stopped and bounds,preconditions hold:
1030 = and(87, 88, 89)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
1031 = or(-991, -125)
# computing x variables for constraints,['?x', '?y+1'] add/sub/none:
# computing y variables for constraints,['?x', '?y+1'] add/sub/none:
# adder circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
1032 = and(125, 126)
# if then constraint for white predicate:
1033 = or(-1011, 1032)
# disjunction for all touched positions:
1034 = or(991, 1011)
# frame axiom; if not touched position, then it is propagated:
1035 = or(1034, 965)
1036 = and(1031, 1033, 1035)
1037 = and(1030, 968)
1038 = or(-1037, 1036)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# computing x variables for constraints,['?x-1', '?y+1'] add/sub/none:
# subtractor circuit
# computing y variables for constraints,['?x-1', '?y+1'] add/sub/none:
# adder circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for white predicate:
1039 = or(-1023, 1032)
# disjunction for all touched positions:
1040 = or(991, 1023)
# frame axiom; if not touched position, then it is propagated:
1041 = or(1040, 965)
1042 = and(1031, 1039, 1041)
1043 = and(1030, 972)
1044 = or(-1043, 1042)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# computing x variables for constraints,['?x+1', '?y+1'] add/sub/none:
# adder circuit
# computing y variables for constraints,['?x+1', '?y+1'] add/sub/none:
# adder circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for white predicate:
# disjunction for all touched positions:
# frame axiom; if not touched position, then it is propagated:
1045 = and(1030, 966)
1046 = or(-1045, 1042)
1047 = and(980, 996, 1015, 1016, 1027, 1028, 1029, 1038, 1044, 1046)
# Player 1 (black) transition function for time step 12: 
# less than constraints for black moves:
1048 = and(91, -92)
1049 = or(-91, 1048)
# propagation constraints:
1050 = or(-125, 127)
1051 = or(-127, 125)
1052 = and(1050, 1051)
1053 = or(-126, 128)
1054 = or(-128, 126)
1055 = and(1053, 1054)
1056 = and(1052, 1055)
1057 = and(-91, -92)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
# less than constraints for negative index bounds:
1058 = and(-94, -95)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
1059 = or(-93, 98)
1060 = or(-98, 93)
1061 = and(1059, 1060)
# new y constraint equality gate with forall y variables: 
1062 = or(-94, 99)
1063 = or(-99, 94)
1064 = and(1062, 1063)
1065 = or(-95, 100)
1066 = or(-100, 95)
1067 = and(1065, 1066)
1068 = and(1064, 1067)
1069 = and(1061, 1068)
1070 = and(125, -126)
# if then constraint for black predicate:
1071 = or(-1069, 1070)
# computing x variables for constraints,['?x', '?y-1'] add/sub/none:
# computing y variables for constraints,['?x', '?y-1'] add/sub/none:
# subtractor circuit
1072 = or(153, 95)
1073 = or(-153, 95)
1074 = or(-95, 153)
1075 = and(1073, 1074)
1076 = or(-1072, 94)
1077 = or(-94, 1072)
1078 = and(1076, 1077)
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
1079 = or(-1078, 99)
1080 = or(-99, 1078)
1081 = and(1079, 1080)
1082 = or(-1075, 100)
1083 = or(-100, 1075)
1084 = and(1082, 1083)
1085 = and(1081, 1084)
1086 = and(1061, 1085)
1087 = or(-1086, -125)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
1088 = or(-1069, -127)
# computing x variables for constraints,['?x', '?y-1'] add/sub/none:
# computing y variables for constraints,['?x', '?y-1'] add/sub/none:
# subtractor circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
1089 = and(127, -128)
# if then constraint for black predicate:
1090 = or(-1086, 1089)
# disjunction for all touched positions:
1091 = or(1069, 1086)
# frame axiom; if not touched position, then it is propagated:
1092 = or(1091, 1056)
# conjunction for all the then constraints:
1093 = and(-1058, 1071, 1087, 1088, 1090, 1092)
# final if then constraint for current action:
1094 = or(-1057, 1093)
1095 = and(-91, 92)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
# less than constraints for negative index bounds:
# less than constraints for negative index bounds:
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for black predicate:
# computing x variables for constraints,['?x-1', '?y-1'] add/sub/none:
# subtractor circuit
1096 = or(-153, 93)
1097 = or(-93, 153)
1098 = and(1096, 1097)
# computing y variables for constraints,['?x-1', '?y-1'] add/sub/none:
# subtractor circuit
# new x constraint equality gate with forall x variables: 
1099 = or(-1098, 98)
1100 = or(-98, 1098)
1101 = and(1099, 1100)
# new y constraint equality gate with forall y variables: 
1102 = and(1101, 1085)
# if then constraint for black predicate:
1103 = or(-1102, -1070)
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# computing x variables for constraints,['?x-1', '?y-1'] add/sub/none:
# subtractor circuit
# computing y variables for constraints,['?x-1', '?y-1'] add/sub/none:
# subtractor circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for black predicate:
1104 = or(-1102, 1089)
# disjunction for all touched positions:
1105 = or(1069, 1102)
# frame axiom; if not touched position, then it is propagated:
1106 = or(1105, 1056)
# conjunction for all the then constraints:
1107 = and(93, -1058, 1071, 1103, 1088, 1104, 1106)
# final if then constraint for current action:
1108 = or(-1095, 1107)
# less than constraints for positive index bounds:
# less than constraints for positive index bounds:
# less than constraints for negative index bounds:
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for black predicate:
# computing x variables for constraints,['?x+1', '?y-1'] add/sub/none:
# adder circuit
# computing y variables for constraints,['?x+1', '?y-1'] add/sub/none:
# subtractor circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for black predicate:
# computing x variables for constraints,['?x', '?y'] add/sub/none:
# computing y variables for constraints,['?x', '?y'] add/sub/none:
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# computing x variables for constraints,['?x+1', '?y-1'] add/sub/none:
# adder circuit
# computing y variables for constraints,['?x+1', '?y-1'] add/sub/none:
# subtractor circuit
# new x constraint equality gate with forall x variables: 
# new y constraint equality gate with forall y variables: 
# if then constraint for black predicate:
# disjunction for all touched positions:
# frame axiom; if not touched position, then it is propagated:
# conjunction for all the then constraints:
1109 = and(-93, -1058, 1071, 1103, 1088, 1104, 1106)
# final if then constraint for current action:
1110 = or(-1048, 1109)
1111 = and(1049, 1094, 1108, 1110)
# ------------------------------------------------------------------------
# Initial state: 
1112 = and(99, 100)
1113 = and(-98, 1112)
1114 = and(98, 1112)
1115 = and(99, -100)
1116 = and(-98, 1115)
1117 = and(98, 1115)
# Or for all black forall position clauses: 
1118 = or(1113, 1114, 1116, 1117)
# if black condition is true then first time step occupied and color black (i.e. 0): 
1119 = or(-1118, 151)
1120 = and(-99, -100)
1121 = and(-98, 1120)
1122 = and(98, 1120)
1123 = and(-99, 100)
1124 = and(-98, 1123)
1125 = and(98, 1123)
# Or for all white forall position clauses: 
1126 = or(1121, 1122, 1124, 1125)
# if white condition is true then first time step occupied and color white (i.e. 1): 
1127 = and(101, 102)
1128 = or(-1126, 1127)
# for all other branches the occupied is 0: 
1129 = or(1118, 1126)
1130 = or(1129, -101)
1131 = and(1119, 1128, 1130)
# ------------------------------------------------------------------------
# Goal state: 
# Black goal constraints: 
# computing x variables for constraints,['?x', '1'] add/sub/none:
# computing y variables for constraints,['?x', '1'] add/sub/none:
# new x constraint equality gate with forall x variables: 
1132 = or(-97, 98)
1133 = or(-98, 97)
1134 = and(1132, 1133)
# y constraint binary format with forall y variables: 
1135 = and(1134, 1120)
# if then constraint for black predicate:
1136 = or(-1135, 1089)
# And gate for black goal constraints, at index 13
# ------------------------------------------------------------------------
# White goal constraints: 
# computing x variables for constraints,['?x', '4'] add/sub/none:
# computing y variables for constraints,['?x', '4'] add/sub/none:
# new x constraint equality gate with forall x variables: 
1137 = or(-98, 98)
# y constraint binary format with forall y variables: 
1138 = and(1137, 1112)
1139 = and(127, 128)
# if then constraint for white predicate:
1140 = or(-1138, -1139)
# And gate for white goal constraints, at index 13
# ------------------------------------------------------------------------
# Nested gates: 
1141 = and(1111, 1136)
# white valid constraints at reverse index: 11
1142 = and(1030, -90)
1143 = or(-1142, 1141)
# propagating to the last: 
1144 = and(1030, 90)
1145 = and(1056, 1140)
1146 = or(-1144, 1145)
1147 = and(1047, 1143, 1146)
# black imply constraints at reverse index: 10
1148 = or(81, 1147)
1149 = or(-123, 127)
1150 = or(-127, 123)
1151 = and(1149, 1150)
1152 = or(-124, 128)
1153 = or(-128, 124)
1154 = and(1152, 1153)
1155 = and(1151, 1154)
1156 = and(1155, 1136)
1157 = or(-81, 1156)
1158 = and(958, 1148, 1157)
# white valid constraints at reverse index: 9
1159 = and(877, -75)
1160 = or(-1159, 1158)
# propagating to the last: 
1161 = or(-121, 127)
1162 = or(-127, 121)
1163 = and(1161, 1162)
1164 = or(-122, 128)
1165 = or(-128, 122)
1166 = and(1164, 1165)
1167 = and(1163, 1166)
1168 = and(877, 75)
1169 = and(1167, 1140)
1170 = or(-1168, 1169)
1171 = and(894, 1160, 1170)
# black imply constraints at reverse index: 8
1172 = or(66, 1171)
1173 = or(-119, 127)
1174 = or(-127, 119)
1175 = and(1173, 1174)
1176 = or(-120, 128)
1177 = or(-128, 120)
1178 = and(1176, 1177)
1179 = and(1175, 1178)
1180 = and(1179, 1136)
1181 = or(-66, 1180)
1182 = and(805, 1172, 1181)
# white valid constraints at reverse index: 7
1183 = and(724, -60)
1184 = or(-1183, 1182)
# propagating to the last: 
1185 = or(-117, 127)
1186 = or(-127, 117)
1187 = and(1185, 1186)
1188 = or(-118, 128)
1189 = or(-128, 118)
1190 = and(1188, 1189)
1191 = and(1187, 1190)
1192 = and(724, 60)
1193 = and(1191, 1140)
1194 = or(-1192, 1193)
1195 = and(741, 1184, 1194)
# black imply constraints at reverse index: 6
1196 = or(51, 1195)
1197 = or(-115, 127)
1198 = or(-127, 115)
1199 = and(1197, 1198)
1200 = or(-116, 128)
1201 = or(-128, 116)
1202 = and(1200, 1201)
1203 = and(1199, 1202)
1204 = and(1203, 1136)
1205 = or(-51, 1204)
1206 = and(652, 1196, 1205)
# white valid constraints at reverse index: 5
1207 = and(571, -45)
1208 = or(-1207, 1206)
# propagating to the last: 
1209 = or(-113, 127)
1210 = or(-127, 113)
1211 = and(1209, 1210)
1212 = or(-114, 128)
1213 = or(-128, 114)
1214 = and(1212, 1213)
1215 = and(1211, 1214)
1216 = and(571, 45)
1217 = and(1215, 1140)
1218 = or(-1216, 1217)
1219 = and(588, 1208, 1218)
# black imply constraints at reverse index: 4
1220 = or(36, 1219)
1221 = or(-111, 127)
1222 = or(-127, 111)
1223 = and(1221, 1222)
1224 = or(-112, 128)
1225 = or(-128, 112)
1226 = and(1224, 1225)
1227 = and(1223, 1226)
1228 = and(1227, 1136)
1229 = or(-36, 1228)
1230 = and(499, 1220, 1229)
# white valid constraints at reverse index: 3
1231 = and(418, -30)
1232 = or(-1231, 1230)
# propagating to the last: 
1233 = or(-109, 127)
1234 = or(-127, 109)
1235 = and(1233, 1234)
1236 = or(-110, 128)
1237 = or(-128, 110)
1238 = and(1236, 1237)
1239 = and(1235, 1238)
1240 = and(418, 30)
1241 = and(1239, 1140)
1242 = or(-1240, 1241)
1243 = and(435, 1232, 1242)
# black imply constraints at reverse index: 2
1244 = or(21, 1243)
1245 = or(-107, 127)
1246 = or(-127, 107)
1247 = and(1245, 1246)
1248 = or(-108, 128)
1249 = or(-128, 108)
1250 = and(1248, 1249)
1251 = and(1247, 1250)
1252 = and(1251, 1136)
1253 = or(-21, 1252)
1254 = and(346, 1244, 1253)
# white valid constraints at reverse index: 1
1255 = and(265, -15)
1256 = or(-1255, 1254)
# propagating to the last: 
1257 = or(-105, 127)
1258 = or(-127, 105)
1259 = and(1257, 1258)
1260 = or(-106, 128)
1261 = or(-128, 106)
1262 = and(1260, 1261)
1263 = and(1259, 1262)
1264 = and(265, 15)
1265 = and(1263, 1140)
1266 = or(-1264, 1265)
1267 = and(282, 1256, 1266)
# black imply constraints at reverse index: 0
1268 = or(6, 1267)
1269 = or(-103, 127)
1270 = or(-127, 103)
1271 = and(1269, 1270)
1272 = or(-104, 128)
1273 = or(-128, 104)
1274 = and(1272, 1273)
1275 = and(1271, 1274)
1276 = and(1275, 1136)
1277 = or(-6, 1276)
1278 = and(193, 1268, 1277)
# ------------------------------------------------------------------------
# Final gate: 
# Conjunction of Initial gate and nested output gate: 
1279 = and(1131, 1278)
